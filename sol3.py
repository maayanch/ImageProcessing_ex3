import numpy as np
from skimage.color import rgb2gray
from scipy.ndimage.filters import convolve
from imageio import imread
import matplotlib.pyplot as plt
import os

MAX_COLOR_VAL = 255


def read_image(filename, representation):
    """
    Function that reads an image file and converts it into a given representation.
    :param filename: the filename of an image on disk (could be grayscale or RGB).
    :param representation: representation code, either 1 or 2 defining whether the output should be
    a grayscale image (1) or an RGB image (2). If the input image is grayscale, we won’t call it
    with representation = 2.
    :return:This function returns an image
    """
    im = imread(filename).astype(np.float64) / MAX_COLOR_VAL
    if representation == 1:
        im = rgb2gray(im)
    return im


def get_gaussian_vector(filter_size):
    '''
    create gaussian vector by given length
    '''
    if filter_size == 1:
        original_value = np.array([1])
        return original_value.reshape(1, 1)
    basic_gauss_vec = np.array([1, 1])
    gaussian = np.copy(basic_gauss_vec)
    for i in range(filter_size - 2):
        gaussian = np.convolve(gaussian, basic_gauss_vec)
    gaussian = gaussian * (1 / np.sum(gaussian))
    return gaussian.reshape(1, filter_size)


def build_gaussian_pyramid(im, max_levels, filter_size):
    '''
     construct a Gaussian pyramid
    :param im:a grayscale image with double values in [0, 1]
    :param max_levels:the maximal number of levels1 in the resulting pyramid.
    :param filter_size:the size of the Gaussian filter (an odd scalar that represents a squared filter) to be used in
     constructing the pyramid filter
    :return:
    '''
    pyr = [im]
    temp_im = np.copy(im)
    filter_vec = get_gaussian_vector(filter_size)
    for i in range(max_levels - 1):
        blur_im = blur(temp_im, filter_vec)
        temp_im = np.copy(blur_im[::2, ::2])
        pyr.append(temp_im)
    return pyr, filter_vec


def blur(temp_im, filter_vec):
    '''
    blur image
    :param temp_im: image to blur
    :param filter_vec: filter to blur with
    :return:
    '''
    blur_ver = convolve(temp_im, filter_vec)
    blur_im = convolve(blur_ver, filter_vec.T)
    return blur_im


def build_laplacian_pyramid(im, max_levels, filter_size):
    '''
    construct a Laplacian pyramid
    :param im: a grayscale image with double values in [0, 1]
    :param max_levels:the maximal number of levels1 in the resulting pyramid.
    :param filter_size:the size of the Gaussian filter (an odd scalar that represents a squared filter) to be used in
     constructing the pyramid filter
    :return:
    '''

    gaus_pyr, filter_vec = build_gaussian_pyramid(im, max_levels, filter_size)
    pyr = []
    for i in range(len(gaus_pyr) - 1):
        expanded_im = expand(filter_vec, gaus_pyr[i + 1])
        L_i = gaus_pyr[i] - expanded_im
        pyr.append(L_i)
    pyr.append(gaus_pyr[len(gaus_pyr) - 1])
    return pyr, filter_vec


def expand(filter_vec, im_orig):
    '''
    expand image, padd it with 0.
    :param filter_vec: filter to expand with
    :param im_orig: image to expand
    :return:
    '''
    new_image = np.zeros(np.array(im_orig.shape) * 2)
    new_image[::2, ::2] = im_orig
    expanded_im = blur(new_image, 2 * filter_vec)
    return expanded_im


def laplacian_to_image(lpyr, filter_vec, coeff):
    """
    the reconstruction of an image from its Laplacian Pyramid
    :param lpyr: the Laplacian pyramid and that generated by the second function
    :param filter_vec: the Laplacian filter that generated by the second function
    :param coeff: is a python list. The list length is the same as the number of levels in the pyramid lpyr.
    :return: image from laplacian pyramid
    """
    if len(lpyr) != len(coeff):
        raise Exception("bad sizes")
    new_pyr = np.array(lpyr) * np.array(coeff)
    new_im = new_pyr[len(new_pyr) - 1]
    for i in range(len(new_pyr) - 1, 0, -1):
        new_im = expand(filter_vec, new_im)
        new_im = new_im + new_pyr[i - 1]
    return new_im


def get_new_im_black(pyr, levels):
    '''
    create new image in tga wanted size, full with 0,
    :param pyr: all the images to marge
    :param levels: number of images to marge
    :return: new image
    '''
    h = pyr[0].shape[0]
    w = 0
    for i in range(levels):
        w += pyr[i].shape[1]
    return np.zeros((h, w))


def render_pyramid(pyr, levels):
    """
    To facilitate the display of pyramids,
    :param pyr:is either a Gaussian or Laplacian pyramid as defined above
    :param levels:is the number of levels2 to present in the result
    :return: new image
    """
    im = get_new_im_black(pyr, levels)
    current_col = 0
    for i in range(min(len(pyr), levels)):
        pyr[i] = (pyr[i] - np.min(pyr[i])) / (np.max(pyr[i]) - np.min(pyr[i]))
        im[0: pyr[i].shape[0], current_col: current_col + pyr[i].shape[1]] = pyr[i]
        current_col += pyr[i].shape[1]
    return im


def display_pyramid(pyr, levels):
    """
    To facilitate the display of pyramids,
    :param pyr:is either a Gaussian or Laplacian pyramid as defined above
    :param levels:is the number of levels2 to present in the result
    """
    im = render_pyramid(pyr, levels)
    plt.imshow(im, cmap='gray')
    plt.show()


def pyramid_blending(im1, im2, mask, max_levels, filter_size_im, filter_size_mask):
    """
    Implement pyramid blending
    :param im1, im2: are two input grayscale images to be blended
    :param mask: is a boolean (i.e. dtype == np.bool) mask containing True and False representing which parts
            of im1 and im2 should appear in the resulting im_blend.
    :param max_levels:– is the max_levels parameter you should use when generating the Gaussian and Laplacian pyramids.
    :param filter_size_im: – is the size of the Gaussian filter (an odd scalar that represents a squared filter) which
            defining the filter used in the construction of the Laplacian pyramids of im1 and im2
    :param filter_size_mask: – is the size of the Gaussian filter(an odd scalar that represents a squared filter) which
            defining the filter used in the construction of the Gaussian pyramid of mask.
    :return:
    """
    lap_pyr1, filter1 = build_laplacian_pyramid(im1, max_levels, filter_size_im)
    lap_pyr2, filter2 = build_laplacian_pyramid(im2, max_levels, filter_size_im)
    gauss_mask_pyr, filter_mask = build_gaussian_pyramid(mask.astype(np.float64), max_levels, filter_size_mask)
    new_pyr = []
    for i in range(max_levels):
        new_pyr.append(gauss_mask_pyr[i] * lap_pyr1[i] + (1 - gauss_mask_pyr[i]) * lap_pyr2[i])
    coeff = [1] * len(new_pyr)
    im_blend = laplacian_to_image(new_pyr, filter_mask, coeff)
    return im_blend.clip(0, 1)


def show_blend_images(im1, im2, mask, im_blend):
    '''
    display 4 image in one image
    '''
    images = [im1, im2, mask, im_blend]
    plt.figure()
    cur_im_index = 0
    for image in images:
        plt.subplot(2, 2, cur_im_index + 1)
        plt.axis('off')
        if image is mask:
            plt.set_cmap('gray')
        plt.imshow(image)
        cur_im_index += 1
    plt.show()


def blending_example1():
    im1 = read_image(relpath('images/d.jpg'), 2)
    im2 = read_image(relpath('images/ee.jpg'), 2)
    mask = read_image(relpath('images/mask1.jpg'), 1).astype(bool)
    im_blend, mask = blend_RGB(im1, im2, mask)
    return im1, im2, mask, im_blend


def blend_RGB(im1, im2, mask):
    mask = mask.astype(bool)
    im_blend = im1.copy()
    im_blend[:, :, 0] = pyramid_blending(im1[:, :, 0], im2[:, :, 0], mask, 3, 7, 7)
    im_blend[:, :, 1] = pyramid_blending(im1[:, :, 1], im2[:, :, 1], mask, 3, 7, 7)
    im_blend[:, :, 2] = pyramid_blending(im1[:, :, 2], im2[:, :, 2], mask, 3, 7, 7)
    show_blend_images(im1, im2, mask, im_blend)
    return im_blend, mask


def blending_example2():
    im1 = read_image(relpath('images/ds.jpg'), 2)
    im2 = read_image(relpath('images/salar.jpg'), 2)
    mask = read_image(relpath('images/mask2.jpg'), 1).astype(bool)
    im_blend, mask = blend_RGB(im1, im2, mask)
    return im1, im2, mask, im_blend


def relpath(filename):
    return os.path.join(os.path.dirname(__file__), filename)
